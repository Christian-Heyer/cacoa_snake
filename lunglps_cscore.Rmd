---
title: "lunglps_scoring.Rmd"
author: "Christian Heyer"
date: "`r Sys.Date()`"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)

#devtools::install_github("scverse/anndataR")
#devtools::install_github("ChangSuBiostats/CS-CORE")

library(anndataR)
library(CSCORE)
library(Seurat)
library(SeuratDisk)
library(SCpubr)
library(tidyverse)
library(patchwork)
```

## R Markdown

This is an R Markdown document. Markdown is a simple formatting syntax for authoring HTML, PDF, and MS Word documents. For more details on using R Markdown see <http://rmarkdown.rstudio.com>.

When you click the **Knit** button a document will be generated that includes both content as well as the output of any embedded R code chunks within the document. You can embed an R code chunk like this:

```{r cars}

h5ad_path <- "/omics/odcf/analysis/OE0228_projects/VascularAging/rna_sequencing/public_scrnaseq/lung_lps/merged/seurat/seurat_obj.rds.gz"
#h5_seuratpath <- 

umap_coords <- "/omics/odcf/analysis/OE0228_projects/VascularAging/rna_sequencing/public_scrnaseq/lung_lps/merged/anndata/csvs/umap_coords.csv"  

#umap_coords <- read.csv(umap_coords)  
#seurat_path <- Convert(source = h5ad_path, dest = "")

adata <- readRDS(h5ad_path)

DefaultAssay(adata) <- "soupX_counts"

# Drop other assays to reclaim memory
#adata[["RNA"]] <- NULL
#adata[["analytic_pearson_residuals"]] <- NULL
#adata[["log1p_norm"]] <- NULL
#adata[["scran_normalization"]] <- NULL
#adata[["counts"]] <- NULL

gc()
```


what

```{r big sad}
adata_small <- adata[,!(adata$cell_type == "Aerocyte")]

adata_small <- FindVariableFeatures(adata_small,assay = "log1p_norm", selection.method = "vst",nfeatures = 6000,mean.cutoff = c(1,8))

#VariableFeaturePlot(adata_small,assay = "log1p_norm",selection.method = "vst")
genes_selected <- VariableFeatures(adata_small, assay = "log1p_norm",)

# Filter Variable Features to remove lowly expressed genes
mean_exp <- rowMeans(adata_small@assays$log1p_norm@data)
#threshold <- 0.5 # Set your desired threshold for mean expression
#filter the bottom 0.2 quantile of genes_selected based on mean_exp
threshold <- 0.2
filtered_genes <- genes_selected[mean_exp[genes_selected] > quantile(mean_exp[genes_selected], threshold)]

hist(mean_exp[genes_selected], breaks = 40)
hist(mean_exp[filtered_genes], breaks = 40)

adata_small$nCount_RNA <- NULL

#length(which(is.nan(adata_small@assays$RNA@counts )))

```

## Including Plots

You can also embed plots, for example:

```{r pressure, eval = F, echo=FALSE}
mean_exp = rowMeans(adata_small@assays$soupX_counts@counts/rowSums(adata_small@assays$soupX_counts@counts, na.rm = T))
#genes_selected = names(sort.int(mean_exp, decreasing = T))[1:5000]
#genes_selected <- c(genes_selected, "Aplnr")
#genes_selected <- VariableFeatures(adata_small, assay = "scran_normalization",)
```

Note that the `echo = FALSE` parameter was added to the code chunk to prevent printing of the R code that generated the plot.

```{r, eval = F}
library(bsub)
#file.remove("/omics/odcf/analysis/OE0228_projects/VascularAging/rna_sequencing/public_scrnaseq/lung_lps/CSCore_res.RDS.gz")
if(!file.exists( "/omics/odcf/analysis/OE0228_projects/VascularAging/rna_sequencing/public_scrnaseq/lung_lps/CSCore_res.RDS.gz")) {
  save.image(file =  "/omics/groups/OE0436/internal/heyer/temp/cscore_image.RData")
  bsub_chunk( name = "test CSCORE", packages = c("Seurat", "CSCORE"), hours = 24, 
              memory = 48,cores = 1, R_version = "4.2.0",image = "/omics/groups/OE0436/internal/heyer/temp/cscore_image.RData", code = {
  adata_small = RenameAssays(adata_small, soupX_counts = "RNA")
  CSCORE_result <- CSCORE(adata_small, genes = c(filtered_genes))
  saveRDS(CSCORE_result, "/omics/odcf/analysis/OE0228_projects/VascularAging/rna_sequencing/public_scrnaseq/lung_lps/CSCore_res.RDS.gz")
  })
}

```


```{r}
cscore_path <- "/omics/odcf/analysis/OE0228_projects/VascularAging/rna_sequencing/public_scrnaseq/lung_lps/CSCore_res.RDS.gz"
CSCORE_result <- readRDS(cscore_path)

CSCORE_coexp <- CSCORE_result$est

all_zero_index <- apply(CSCORE_coexp, 1, function(x) all(x==0 | x == 1))

# remove genes from CSCORE_coexp that are all zero
CSCORE_coexp <- CSCORE_coexp[!all_zero_index, !all_zero_index]

CSCORE_p <- CSCORE_result$p_value
CSCORE_p <- CSCORE_p[!all_zero_index, !all_zero_index]

p_matrix_BH = matrix(0, length(rownames(CSCORE_coexp)), length(rownames(CSCORE_coexp)))
p_matrix_BH[upper.tri(p_matrix_BH)] = p.adjust(CSCORE_p[upper.tri(CSCORE_p)], method = "BH")
p_matrix_BH <- p_matrix_BH + t(p_matrix_BH)


hist(CSCORE_p, main = "p_values")
hist(p_matrix_BH, main = "BH adj. p values")

# Set co-expression entires with BH-adjusted p-values greater than 0.05 to 0
CSCORE_coexp[p_matrix_BH > 0.05] <- 0

powers <- c(c(1:10), seq(from = 12, to = 20, by = 2))
  
library(WGCNA)
softThreshold <- WGCNA::pickSoftThreshold.fromSimilarity(abs(CSCORE_coexp),powerVector = powers,verbose = 3)
point_size = 5
text_size = 3
pt <- softThreshold$fitIndices

soft_power <- softThreshold$powerEstimate
if (is.na(soft_power)) {
  soft_power <- 2
}
sft_r <- as.numeric(pt[pt$Power == soft_power, "SFT.R.sq"])
mean_k <- as.numeric(pt[pt$Power == soft_power, "mean.k."])
median_k <- as.numeric(pt[pt$Power == soft_power, "median.k."])
max_k <- as.numeric(pt[pt$Power == soft_power, "max.k."])
pt$text_color <- ifelse(pt$Power == soft_power, "white", 
             "black")
p1 <- pt %>% ggplot(aes(x = Power, y = SFT.R.sq)) + geom_rect(data = pt[1, 
           ], aes(xmin = -Inf, xmax = Inf, ymin = -Inf, ymax = 0.8), 
             fill = "grey80", alpha = 0.8, color = NA) + geom_hline(yintercept = sft_r, 
             linetype = "dashed") + geom_vline(xintercept = soft_power, 
             linetype = "dashed") + geom_point(data = pt[pt$Power == 
             soft_power, c("Power", "SFT.R.sq")], aes(x = Power, 
             y = SFT.R.sq), inherit.aes = FALSE, color = "black", 
             size = point_size) + geom_text(label = pt$Power, 
             color = pt$text_color, size = text_size) + scale_y_continuous(limits = c(0, 
             1), breaks = c(0, 0.2, 0.4, 0.6, 0.8, 1)) + ylab("Scale-free Topology Model Fit") + 
             xlab("Soft Power Threshold") + theme(axis.line.x = element_blank(), 
             axis.line.y = element_blank(), panel.border = element_rect(colour = "black", 
                 fill = NA, size = 1))
p2 <- pt %>% ggplot(aes(x = Power, y = mean.k.)) + 
                 geom_hline(yintercept = mean_k, linetype = "dashed") + 
                 geom_vline(xintercept = soft_power, linetype = "dashed") + 
                 geom_point(data = pt[pt$Power == soft_power, 
                   c("Power", "mean.k.")], aes(x = Power, y = mean.k.), 
                   inherit.aes = FALSE, color = "black", size = point_size) + 
                 geom_text(label = pt$Power, color = pt$text_color, 
                   size = text_size) + scale_y_continuous(labels = scales::comma) + 
                 ylab("Mean Connectivity") + xlab("Soft Power Threshold") + 
                 theme(axis.line.x = element_blank(), axis.line.y = element_blank(), 
                   panel.border = element_rect(colour = "black", 
                     fill = NA, size = 1))
p3 <- pt %>% ggplot(aes(x = Power, y = median.k.)) + 
                 geom_hline(yintercept = median_k, linetype = "dashed") + 
                 geom_vline(xintercept = soft_power, linetype = "dashed") + 
                 geom_point(data = pt[pt$Power == soft_power, 
                   c("Power", "median.k.")], aes(x = Power, y = median.k.), 
                   inherit.aes = FALSE, color = "black", size = point_size) + 
                 geom_text(label = pt$Power, color = pt$text_color, 
                   size = text_size) + scale_y_continuous(labels = scales::comma) + 
                 ylab("Median Connectivity") + xlab("Soft Power Threshold") + 
                 theme(axis.line.x = element_blank(), axis.line.y = element_blank(), 
                   panel.border = element_rect(colour = "black", 
                     fill = NA, size = 1))
p4 <- pt %>% ggplot(aes(x = Power, y = max.k.)) + 
                 geom_hline(yintercept = max_k, linetype = "dashed") + 
                 geom_vline(xintercept = soft_power, linetype = "dashed") + 
                 geom_point(data = pt[pt$Power == soft_power, 
                   c("Power", "max.k.")], aes(x = Power, y = max.k.), 
                   inherit.aes = FALSE, color = "black", size = point_size) + 
                 geom_text(label = pt$Power, color = pt$text_color, 
                   size = text_size) + scale_y_continuous(labels = scales::comma) + 
                 ylab("Max Connectivity") + xlab("Soft Power Threshold") + 
                 theme(axis.line.x = element_blank(), axis.line.y = element_blank(), 
                   panel.border = element_rect(colour = "black", 
                     fill = NA, size = 1))

wrap_plots(p1,p2,p3,p4)             
             # Plot softThreshold plots
plot(softThreshold$fitIndices[,1], softThreshold$fitIndices[,2],
     xlab="Soft Threshold (power)",ylab="Scale Free Topology Model Fit, R^2",type="l",
     main = paste("Scale independence"))
```

## Networks

### Signed Network

```{r}
# Compute the adjacency matrix based on the co-expression matrix
adj = WGCNA::adjacency.fromSimilarity(CSCORE_coexp, power = 2,type = "signed")
# Compute the topological overlap matrix
TOM = WGCNA::TOMsimilarity(adj, TOMType = "signed")
dissTOM = 1-TOM
rownames(dissTOM) <- colnames(dissTOM) <- rownames(CSCORE_coexp)
# Run hierarchical clustering as in the WGCNA workflow
hclust_dist = hclust(as.dist(dissTOM), method = "average") 
memb = dynamicTreeCut::cutreeDynamic(dendro = hclust_dist, 
                     distM = dissTOM, 
                     deepSplit = 2,
                     pamRespectsDendro = FALSE,
                     minClusterSize = 10,)
# For more instructions on how to tune the parameters in the WGCNA workflow,
# please refer to https://horvath.genetics.ucla.edu/html/CoexpressionNetwork/Rpackages/WGCNA/Tutorials/

names(memb) = rownames(CSCORE_coexp)
memb_tab <- table(memb)
memb_tab

module_list_signed = lapply(sort(unique(memb)), function(i_k) names(which(memb == i_k)))
```


```{r}
merged_colors <- labels2colors(memb)
names(merged_colors) <- names(memb)
plotDendroAndColors(hclust_dist,colors = memb,  dendroLabels = FALSE,
  hang = 0.03,
  addGuide = TRUE,
  guideHang = 0.05 )
#exprData <- adata_small@assays$log1p_norm@data
#moduleColors <- mergeCloseModules(as.matrix(t(exprData[rownames(CSCORE_coexp),])), memb, cutHeight = 0.25, verbose = 3)
```

### Unsigned Network

```{r}
# Compute the adjacency matrix based on the co-expression matrix
adj = WGCNA::adjacency.fromSimilarity(abs(CSCORE_coexp), power = 2)
# Compute the topological overlap matrix
TOM = WGCNA::TOMsimilarity(adj, TOMType = "unsigned")
dissTOM = 1-TOM
rownames(dissTOM) <- colnames(dissTOM) <- rownames(CSCORE_coexp)
# Run hierarchical clustering as in the WGCNA workflow
hclust_dist = hclust(as.dist(dissTOM), method = "average") 
memb = dynamicTreeCut::cutreeDynamic(dendro = hclust_dist, 
                     distM = dissTOM, 
                     deepSplit = 2,
                     pamRespectsDendro = FALSE,
                     minClusterSize = 30,)
# For more instructions on how to tune the parameters in the WGCNA workflow,
# please refer to https://horvath.genetics.ucla.edu/html/CoexpressionNetwork/Rpackages/WGCNA/Tutorials/

names(memb) = rownames(CSCORE_coexp)
memb_tab <- table(memb)
memb_tab

module_list_unsigned = lapply(sort(unique(memb)), function(i_k) names(which(memb == i_k)))
```


```{r}
merged_colors <- labels2colors(memb)
names(merged_colors) <- names(memb)
plotDendroAndColors(hclust_dist,colors = memb,  dendroLabels = FALSE,
  hang = 0.03,
  addGuide = TRUE,
  guideHang = 0.05 )
#exprData <- adata_small@assays$log1p_norm@data
#moduleColors <- mergeCloseModules(as.matrix(t(exprData[rownames(CSCORE_coexp),])), memb, cutHeight = 0.25, verbose = 3)
```


Around 500 Genes were set to 0 due to negative variance estimates -> Check which genes are affected and why


```{r}
all_zero_index <- apply(CSCORE_result$est, 1, function(x) all(x==0 | x == 1))

adata_small[names(which(all_zero_index)),] -> stunted_seurat

hist(mean_exp[names(which(all_zero_index))], breaks = 40)

hist(mean_exp[names(which(!all_zero_index))], breaks = 40)

stunded_var <- apply(stunted_seurat@assays$soupX_counts$counts,1,var)

plot(density(log10(stunded_var)))

normal_var <- apply(adata_small[filtered_genes,]@assays$soupX_counts$counts,1,var)

plot(density(log10(normal_var)))
```

### Cluster Profiler analysis

#### Unsigned Modules


```{r}
if (!require(clusterProfiler)) {
  BiocManager::install("clusterProfiler")
  library(clusterProfiler)
}else{
  library(clusterProfiler)
}
```

```{r}
# Set all genes in clustering analysis as background,
# such that the enrichment result of any module is not attributed to its high expression levels.
universe <- rownames(CSCORE_coexp)

# Filter GO terms based on BH-adjusted p values < 0.05
####
## Note: the following codes can take a long time to run as 
## in this example there are more than 100 co-expressed gene modules from WGCNA
####
library(furrr)
plan(strategy = "multicore",workers = 6)
#plan(strategy = "sequential")
ego_result_unsigned <- furrr::future_map(module_list_unsigned, function(i){
  enrichGO(gene = i,
         OrgDb = 'org.Mm.eg.db', # human
         keyType = "SYMBOL",
         ont = "ALL",
         pAdjustMethod = "BH",
         universe = universe,
         pvalueCutoff = 0.05)
})




```

```{r}
top_enrich_clusters <- which(sapply(ego_result_unsigned, function(x) 
  (x@result$p.adjust[1] < 0.01) & (dim(x)[1]>10)))
top_enrich_go <- lapply(top_enrich_clusters, function(i) ego_result_unsigned[[i]]@result[1:3,])
```

```{r}
for(i in 1:length(top_enrich_go)){
  print(top_enrich_go[[i]][, c('Description', 'GeneRatio', 'p.adjust')])
  cat('\n')
}
```

Check which Modules correlate with Aplnr

```{r}

gene <- "Aplnr"

aplnr_res <- purrr::map_lgl(module_list_unsigned, function(x) gene %in% x)

which(aplnr_res)

ego_result_unsigned[aplnr_res] 

if (nrow(ego_result_unsigned[[which(aplnr_res)]]@result ) > 0) {
  clusterProfiler::dotplot(ego_result_unsigned[[which(aplnr_res)]])
}

module_list_unsigned[[which(aplnr_res)]]
```

#### Signed Networks


```{r}
# Set all genes in clustering analysis as background,
# such that the enrichment result of any module is not attributed to its high expression levels.
universe <- rownames(CSCORE_coexp)
EC_senes <- RNAscripts::senes
# Filter GO terms based on BH-adjusted p values < 0.05
####
## Note: the following codes can take a long time to run as 
## in this example there are more than 100 co-expressed gene modules from WGCNA
####
library(furrr)
plan(strategy = "multicore",workers = 6)
#plan(strategy = "sequential")
ego_result_signed <- furrr::future_map(module_list_signed, function(i){
  enrichGO(gene = i,
         OrgDb = 'org.Mm.eg.db', # human
         keyType = "SYMBOL",
         ont = "ALL",
         pAdjustMethod = "BH",
         universe = universe,
         pvalueCutoff = 0.05)
})
# Run enrichments against senescence gene signatures
ego_result_senescence <- furrr::future_map(module_list_signed, function(i){
  enricher(gene = i,
         TERM2GENE = EC_senes,
         pvalueCutoff = 0.05,
         pAdjustMethod = "BH",
         qvalueCutoff = 0.05,
         minGSSize = 5,
         maxGSSize = 500,
         universe = universe,
       )
  }
)



```

```{r}
top_enrich_clusters <- which(sapply(ego_result_signed, function(x) 
  (x@result$p.adjust[1] < 0.01) & (dim(x)[1]>10)))
top_enrich_go <- lapply(top_enrich_clusters, function(i) ego_result_signed[[i]]@result[1:3,])
```

```{r}
for(i in 1:length(top_enrich_go)){
  print(top_enrich_go[[i]][, c('Description', 'GeneRatio', 'p.adjust')])
  cat('\n')
  p <- dotplot(ego_result_signed[[i]]) + ggtitle(paste0("signature ", i)) 
  print(p)  
}
```


```{r}
top_enrich_clusters <- which(sapply(ego_result_senescence, function(x) 
  (x@result$p.adjust[1] < 0.05) ))
top_enrich_go <- lapply(top_enrich_clusters, function(i) ego_result_senescence[[i]]@result[1:3,])
for(i in top_enrich_clusters){
#  print(top_enrich_go[[i]][, c('Description', 'GeneRatio', 'p.adjust')])
  cat('\n')
  p <- dotplot(ego_result_senescence[[i]]) + ggtitle(paste0("signature ", i)) 
  print(p)  
}
```

Check which Modules correlate with Aplnr

```{r}

gene <- "Aplnr"

aplnr_res <- purrr::map_lgl(module_list_signed, function(x) gene %in% x)

which(aplnr_res)

ego_result_signed[aplnr_res] 

if (nrow(ego_result_signed[[which(aplnr_res)]]@result ) > 0) {
  clusterProfiler::dotplot(ego_result_signed[[which(aplnr_res)]])
}

module_list_signed[[which(aplnr_res)]]
```


### Aplnr Correlations


```{r}
adata_small <- Seurat::AddModuleScore(adata_small, features = module_list_signed,assay = "log1p_norm", name = "CSCORE_signed")

adata_small <- Seurat::AddModuleScore(adata_small, features = module_list_unsigned,assay = "log1p_norm", name = "CSCORE_unsigned")
```

```{r}
SCpubr::do_DimPlot(adata_small, group.by = "sample")

```


```{r, fig.height = 12, fig.width= 12}

SCpubr::do_FeaturePlot(adata_small, features =  paste0("CSCORE_unsigned", 1:10))

SCpubr::do_ViolinPlot(adata_small, group.by = "sample", 
                      features =    paste0("CSCORE_unsigned", 1:10))
```

### Signed Networks


```{r fig.height = 12, fig.width= 14}
SCpubr::do_FeaturePlot(adata_small, features =  paste0("CSCORE_signed", 1:length(module_list_signed)))



SCpubr::do_ViolinPlot(adata_small, group.by = "sample", 
                      features =    paste0("CSCORE_signed", 1:length(module_list_signed)))
```


## Aplnr Correlation analysis

We can use the correlation of Aplnr to run enrichment analysis on what processes are correlated with Aplnr. 

```{r}
library(decoupleR)
# get the correlation of Aplnr to all genes
p_vals <- CSCORE_result$p_value
# set 0 p values to 10e-320
p_vals[p_vals == 0] <- 10e-320
# Check that no pvalues are 0
stopifnot(length(which(p_vals == 0)) == 0)

CSCORE_result$est * -log10(p_vals) -> gsea_rank_matrix
aplnr_gsea_rank <- gsea_rank_matrix[,"Aplnr"]
aplnr_cor <- CSCORE_result$est[, "Aplnr"]
sort(aplnr_cor, decreasing = T) -> sorted_aplnr_cor
aplnr_tb <- tibble(names(aplnr_cor), aplnr_cor)
#mat <- as.matrix(data@assays$RNA@data)
sample_acts <- run_mlm(mat=aplnr_tb, network =net, .source='source', .target='target',
                  .mor='weight', minsize = 5)
plot(density(aplnr_cor))

```

Show the list of genes that are highly correlated and anticorrleated with Aplnr

```{r}
aplnr_tb %>% arrange(desc(aplnr_cor)) %>% head(30)
aplnr_tb %>% arrange(aplnr_cor) %>% head(10)
```



Now we use aplnr_cor to run Gene set enrichment analysis. 


```{r}
# Get MsigDB gene sets
library(msigdbr)

msigdbr::msigdbr(species = "Mus musculus", category = "H") -> msigdb

msigdb %>% as_tibble() %>% select(gs_name, gene_symbol) -> msigdb_tb
colnames(msigdb_tb) <- c("source", "target")
EC_senes <- RNAscripts::senes



decoupleR::run_fgsea(as.matrix(aplnr_cor), EC_senes)
decoupleR::run_fgsea(as.matrix(aplnr_cor), distinct(msigdb_tb))

# Get the gene sets
msig_enrich <- RNAscripts::run_msig_enricher(gset_list = list(aplnr_tb), 
      GSEA = T, category ="H", 
      subcategory = NULL, species = "Mus musculus", 
      msdb_var = "gene_symbol", input_type = "gene_symbol")
enrich_obj <- clusterProfiler::GSEA(sort(aplnr_cor, decreasing = T),TERM2GENE = EC_senes)

```

```{r, fig.height = 16, fig.width=12}
 RNAscripts::better_dotplot(msig_enrich[[1]], c_groups = c("corr", "AntiCor"))

```


```{r, fig.height = 10}
RNAscripts::better_dotplot(enrich_obj, c_groups = c("corr", "AntiCor"))

enrich_obj@result
```


```{r}
library(OmnipathR)
library(decoupleR)
pog <- decoupleR::get_progeny(organism = "mouse",top = 200)
doro <- decoupleR::get_collectri(organism="mouse", split_complexes = TRUE)

progeny <- decouple(data.frame("aplnr_cor" = aplnr_cor), pog)
tri_test <- decouple(data.frame("aplnr_cor" = aplnr_cor), doro)
```

```{r}
mat_consensus <- progeny %>%
    filter(statistic=='consensus') %>% dplyr::mutate(padj = p.adjust(p_value)) %>% arrange(desc(score)) %>%
    pivot_wider_profile(id_cols = source, names_from = condition, 
                        values_from = score) %>%
    as.matrix()

pheatmap::pheatmap(mat_consensus, cluster_rows = F, cluster_cols = F, color = colorRampPalette(c("blue", "white", "red"))(100))
```


```{r}
mat_consensus <- tri_test %>%
    filter(statistic=='consensus' & p_value <=0.1) %>%
    pivot_wider_profile(id_cols = source, names_from = condition, 
                        values_from = score) %>%
    as.matrix()

# color palette blue,white,red
pheatmap::pheatmap(mat_consensus, cluster_rows = T, cluster_cols = F, color = colorRampPalette(c("blue", "white", "red"))(100))
```


```{r}

enrich_obj <- clusterProfiler::GSEA(sort(aplnr_cor, decreasing = T),TERM2GENE = EC_senes)

```